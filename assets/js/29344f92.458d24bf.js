"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[3986],{5845:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>n,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"api/api/index","title":"@skipruntime/api","description":"Interfaces","source":"@site/docs/api/api/index.md","sourceDirName":"api/api","slug":"/api/api/","permalink":"/docs/api/api/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Reference","permalink":"/docs/reference"},"next":{"title":"Context","permalink":"/docs/api/api/interfaces/Context"}}');var a=s(4848),r=s(8453);const n={},c="@skipruntime/api",d={},l=[{value:"Interfaces",id:"interfaces",level:2},{value:"Classes",id:"classes",level:2},{value:"Type Aliases",id:"type-aliases",level:2}];function o(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"skipruntimeapi",children:"@skipruntime/api"})}),"\n",(0,a.jsx)(t.h2,{id:"interfaces",children:"Interfaces"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Interface"}),(0,a.jsx)(t.th,{children:"Description"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/interfaces/Context",children:"Context"})}),(0,a.jsx)(t.td,{children:"-"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/interfaces/EagerCollection",children:"EagerCollection"})}),(0,a.jsxs)(t.td,{children:["An ",(0,a.jsx)(t.em,{children:"Eager"})," reactive collection, whose values are computed eagerly and kept up to date whenever inputs are changed"]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/interfaces/ExternalService",children:"ExternalService"})}),(0,a.jsx)(t.td,{children:"External services must be carefully managed in reactive Skip services to make sure that dependencies are properly tracked and data from external systems is kept up to date."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/interfaces/LazyCollection",children:"LazyCollection"})}),(0,a.jsxs)(t.td,{children:["A ",(0,a.jsx)(t.em,{children:"Lazy"})," reactive collection, whose values are computed only when queried"]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/interfaces/LazyCompute",children:"LazyCompute"})}),(0,a.jsxs)(t.td,{children:["The type of a ",(0,a.jsx)(t.em,{children:"lazy"})," reactive function which produces a value for some ",(0,a.jsx)(t.code,{children:"key"}),", possibly using a ",(0,a.jsx)(t.code,{children:"self"})," reference to get/produce other lazily-computed results."]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/interfaces/Mapper",children:"Mapper"})}),(0,a.jsx)(t.td,{children:"The type of a reactive function mapping over an arbitrary collection. For each element (association of key of type K1 to values of type V1) in the input collection, produces some key-value pairs for the output collection (of types K2 and V2 respectively). The output collection will itself combine multiple values for each individual key."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/interfaces/NonEmptyIterator",children:"NonEmptyIterator"})}),(0,a.jsx)(t.td,{children:"A mutable iterator with at least one element"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/interfaces/Reducer",children:"Reducer"})}),(0,a.jsx)(t.td,{children:"The type of a reactive reducer function, which computes an output value over a collection as values are added/removed"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/interfaces/Resource",children:"Resource"})}),(0,a.jsxs)(t.td,{children:[(0,a.jsx)(t.code,{children:"Resource"}),"s make up the public interface of a SkipService, specifying how to respond to reactive requests, either by accessing data from the static computation graph generated in the service's ",(0,a.jsx)(t.code,{children:"createGraph"})," function or extending it with further reactive computations as needed to handle the request."]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/interfaces/SkipService",children:"SkipService"})}),(0,a.jsx)(t.td,{children:"-"})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"classes",children:"Classes"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Class"}),(0,a.jsx)(t.th,{children:"Description"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/classes/ManyToOneMapper",children:"ManyToOneMapper"})}),(0,a.jsxs)(t.td,{children:["A specialized form of ",(0,a.jsx)(t.code,{children:"Mapper"})," which maps values many-to-one, reusing the input collection's key structure in the output collection. Use this form to map all the values associated with a key to a single output value for that key. This saves some boilerplate: instead of writing the fully general ",(0,a.jsx)(t.code,{children:"mapEntry"})," that potentially modifies, adds, or removes keys, just implement the simpler ",(0,a.jsx)(t.code,{children:"mapValues"})," to transform the values associated with each key."]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/classes/NonUniqueValueException",children:"NonUniqueValueException"})}),(0,a.jsxs)(t.td,{children:["An exception indicating that ",(0,a.jsx)(t.code,{children:"getUnique"})," was called on a structure without a unique element"]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/classes/OneToOneMapper",children:"OneToOneMapper"})}),(0,a.jsxs)(t.td,{children:["A specialized form of ",(0,a.jsx)(t.code,{children:"Mapper"})," which maps values one-to-one, reusing the input collection's key structure in the output collection. Use this form to map each value associated with a key to an output value for that key. This saves some boilerplate: instead of writing the fully general ",(0,a.jsx)(t.code,{children:"mapEntry"})," that potentially modifies, adds, or removes keys, just implement the simpler ",(0,a.jsx)(t.code,{children:"mapValue"})," to transform individual values."]})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"type-aliases",children:"Type Aliases"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Type alias"}),(0,a.jsx)(t.th,{children:"Description"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/type-aliases/CollectionUpdate",children:"CollectionUpdate"})}),(0,a.jsxs)(t.td,{children:["Represents some update(s) to a collection, containing: an array of all updated keys and their new ",(0,a.jsx)(t.code,{children:"values"}),", where an empty value array indicates deletion; a new ",(0,a.jsx)(t.code,{children:"watermark"})," for the point after these updates; and, a flag ",(0,a.jsx)(t.code,{children:"isInitial"})," which is set when this update is the initial chunk of data rather than an update to the preceding state."]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/type-aliases/Entry",children:"Entry"})}),(0,a.jsx)(t.td,{children:"-"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/type-aliases/InitialData",children:"InitialData"})}),(0,a.jsx)(t.td,{children:"-"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/type-aliases/Json",children:"Json"})}),(0,a.jsxs)(t.td,{children:["The ",(0,a.jsx)(t.code,{children:"Json"})," type describes JSON-serializable values and serves as an upper bound on keys and values in the Skip Runtime, ensuring that they can be serialized and managed by the reactive computation engine."]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/type-aliases/JsonObject",children:"JsonObject"})}),(0,a.jsx)(t.td,{children:"-"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/type-aliases/NamedCollections",children:"NamedCollections"})}),(0,a.jsx)(t.td,{children:"-"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/type-aliases/Param",children:"Param"})}),(0,a.jsxs)(t.td,{children:["A ",(0,a.jsx)(t.code,{children:"Param"})," is a valid parameter to a Skip runtime mapper function: either a constant JS value or a Skip-runtime-managed value. In either case, restricting mapper parameters to this type helps developers to ensure that reactive computations can be reevaluated as needed with consistent semantics. ",(0,a.jsx)(t.code,{children:"Constant"}),"s are deep-frozen objects managed by the Skip runtime; non-Skip objects can be made constant by passing them to ",(0,a.jsx)(t.code,{children:"deepFreeze"}),"."]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/type-aliases/SubscriptionID",children:"SubscriptionID"})}),(0,a.jsx)(t.td,{children:"-"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"/docs/api/api/type-aliases/Watermark",children:"Watermark"})}),(0,a.jsx)(t.td,{children:"-"})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>n,x:()=>c});var i=s(6540);const a={},r=i.createContext(a);function n(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:n(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);