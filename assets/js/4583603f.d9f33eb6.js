"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[8984],{9738:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var i=n(6376),a=n(4848),r=n(8453);const s={title:"Event-Hidden Architectures",description:"Interactive features without events",slug:"event-hidden-arch",date:new Date("2025-04-21T00:00:00.000Z"),authors:"charles"},o=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Event-Hidden Architectures",id:"event-hidden-architectures",level:2},{value:"How did we get here?",id:"how-did-we-get-here",level:3},{value:"10 years of bad advice",id:"10-years-of-bad-advice",level:3},{value:"<del>Event-driven</del> vs event-hidden",id:"event-driven-vs-event-hidden",level:3},{value:"New powers",id:"new-powers",level:3},{value:"Conclusion",id:"conclusion",level:3}];function d(e){const t={a:"a",del:"del",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"event-hidden-architectures",children:"Event-Hidden Architectures"}),"\n",(0,a.jsx)(t.h3,{id:"how-did-we-get-here",children:"How did we get here?"}),"\n",(0,a.jsx)(t.p,{children:"One of the most powerful and consistent trends in software for the past decade has been the move from single stack to cloud native applications.  Cloud native applications are inherently distributed and have become popular as developers are drawn to the convenience of containers and platform-as-a-service infrastructure."}),"\n",(0,a.jsx)(t.p,{children:"The API-ification of important subsystems means today hardly anyone would consider implementing their own payments, shipping, SMS, chat, billing or shopping cart functionality.  Instead they\u2019ll lean on Stripe, Twilio, Shopify, Shippo, etc; accelerating time-to-value and further distributing the functions of the application."}),"\n",(0,a.jsx)(t.p,{children:"In the last few years developers have moved quickly to incorporate more and diverse AI features into their applications, but AI models and application logic compute requirements are quite different from one another and therefore seldom run in the same stack, further distributing the application."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Example architecture diagram",src:n(558).A+"",width:"1999",height:"950"})}),"\n",(0,a.jsx)(t.p,{children:"Some have called for a \u201cback to basics\u201d approach of a single stack or modular monolith, but given the list of external demands on modern application development, distributed is unlikely to go away.  Instead it\u2019s becoming a more common approach for application architectures, not less, especially for \u201csuccessful\u201d applications that need to modularize to support more customers, users and features."}),"\n",(0,a.jsx)(t.h3,{id:"10-years-of-bad-advice",children:"10 years of bad advice"}),"\n",(0,a.jsx)(t.p,{children:"One can sympathize with the desire for a \u201cback to basics\u201d approach to cloud-native applications.  There are many \u201cpros\u201d to writing cloud-native, distributed applications but living with them has been miserable for developers and operators alike.  \u201cCloud native\u201d is effectively synonymous with \u201cdistributed,\u201d and \u201cdistributed\u201d is another way to say a network is parked in the middle of the application.  This changes engineering and operations in many big and subtle ways.  The most common and questionable advice to tackle these challenges has been \u201cevent-driven.\u201d"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Events everywhere buzz lightyear",src:n(810).A+"",width:"888",height:"500"})}),"\n",(0,a.jsx)(t.p,{children:"Events are the biggest reason why engineering teams try to postpone distributed or microservice architectures for as long as possible.  \u201cCloud native\u201d and \u201cmicroservices\u201d have unwittingly become synonymous with \u201cevent-driven\u201d and sullied their reputations in the process."}),"\n",(0,a.jsx)(t.p,{children:"Events remain a useful technical mechanism to transmit state and data among application resources but they are a miserable experience for developers and operators alike.  Events:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Put application state and data in dozens of queues that make the application prone to failures, race conditions and incorrect results"}),"\n",(0,a.jsx)(t.li,{children:"Force developers to think and program asynchronously which is more complex and time consuming than synchronous code"}),"\n",(0,a.jsx)(t.li,{children:"Require developers know more than just their portion of the code and application domain: they also need to understand how to work with queues, caches and event schemas"}),"\n",(0,a.jsx)(t.li,{children:"Make applications difficult to troubleshoot as there is no one place to understand the state and data for an application"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Revolution against API schemas",src:n(9316).A+"",width:"1024",height:"1024"})}),"\n",(0,a.jsxs)(t.h3,{id:"event-driven-vs-event-hidden",children:[(0,a.jsx)(t.del,{children:"Event-driven"})," vs event-hidden"]}),"\n",(0,a.jsxs)(t.p,{children:["The event-driven approach ",(0,a.jsx)(t.em,{children:"was"})," necessary in 2020 but it isn\u2019t any longer in 2025.  Today\u2019s modern abstractions ensure it\u2019s unnecessary to make a faustian bargain between the flexibility & scale of distributed and the existential dread inspired by event-driven architectures."]}),"\n",(0,a.jsx)(t.p,{children:"There are three innovations that together allow us to engineer applications as event-driven but where developers and operators are fully abstracted away from the events themselves."}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://react.dev/",children:"React"})," paired with client state management frameworks like ",(0,a.jsx)(t.a,{href:"https://redux.js.org/",children:"Redux"}),", ",(0,a.jsx)(t.a,{href:"https://xstate.js.org/",children:"Xstate"})," or ",(0,a.jsx)(t.a,{href:"https://zustand-demo.pmnd.rs/",children:"Zustand"})," create a simple, productive experience for frontend engineering.  Frontend engineers are able to implement simple, performant UI components that can support complex application behaviors while outsourcing state and DOM management to the framework."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Durable execution systems like ",(0,a.jsx)(t.a,{href:"https://temporal.io/",children:"Temporal"}),", ",(0,a.jsx)(t.a,{href:"https://restate.dev/",children:"Restate"})," and ",(0,a.jsx)(t.a,{href:"https://www.dbos.dev/",children:"DBOS"})," ensure distributed backend application writes are always correct within and across services and network boundaries because each function call is durable by default.  All of the convenient guarantees of an ACID transaction are injected into the everyday programming experience."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["Reactive frameworks for incremental computation like ",(0,a.jsx)(t.a,{href:"https://github.com/SkipLabs/skip",children:"Skip"})," make it simple to implement distributed application reads from multiple sources and latencies to disparate clients and views.  Developers can blend data from multiple REST and/or streaming sources but write their logic as simple map functions free from references to infrastructure or events.  Because the services are reactive, performance and correctness concerns like cache invalidations are outsourced to the framework."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"All three technologies share many of the same design principles.  Each technology caters to a different area of the application (client changes, backend writes, backend reads) but they all:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Provide a declarative developer experiences free from references to infrastructure"}),"\n",(0,a.jsx)(t.li,{children:"Are event-driven \u201cunder the covers\u201d but don\u2019t leak these details to users"}),"\n",(0,a.jsx)(t.li,{children:"Work asynchronously, supporting high levels of concurrency but still make the developer experience feel effectively synchronous"}),"\n",(0,a.jsx)(t.li,{children:"Manage and in some cases enforce immutability of functions and/or data"}),"\n",(0,a.jsx)(t.li,{children:"Handle application state as a first class concern"}),"\n",(0,a.jsx)(t.li,{children:"Allow for modularity and incremental adoption - they don\u2019t enforce \u201cone pure approach\u201d on an entire application"}),"\n",(0,a.jsx)(t.li,{children:"Can run locally or globally"}),"\n",(0,a.jsx)(t.li,{children:"Are open source"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Collectively, these frameworks provide a substantial upgrade to applications across developer experience, feature velocity, correctness, efficiency and operational reliability.  Software development returns to a simpler, low context model; developers do not need to learn the unique quirks of low level infrastructure or understand the overall application architecture just to build or enhance their part of the application."}),"\n",(0,a.jsx)(t.h3,{id:"new-powers",children:"New powers"}),"\n",(0,a.jsx)(t.p,{children:"Burying events doesn\u2019t just simplify engineering, it grants engineers with new powers in the process."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Transparency"})}),"\n",(0,a.jsx)(t.p,{children:"Ironically, with event-hidden engineering, every behavior of the application is now more visible in an actionable way because events are held in lower layers of the stack that understand their semantics and context."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"State Handling"})}),"\n",(0,a.jsx)(t.p,{children:"Events are not the only thing that get hidden.  By extension state handling, state changes and their implications for correctness are also buried in this new model.  The new developer experience is just implementing as if forever at \u201cinit time.\u201d  All the progressions to get from 1 init time state to a future init time state are handled by the platforms powering the event-hidden architecture."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Replayability"})}),"\n",(0,a.jsx)(t.p,{children:"Lastly, event-hidden architectures nearly always enable replayability.  Keeping events and state in a separate, well abstracted place makes it possible to give developers and operations teams a general way to time travel through the application\u2019s computation."}),"\n",(0,a.jsx)(t.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(t.p,{children:"In 2025 it turns out you can go home again: you can build feature-rich, scaled, distributed applications without having to interact with events, queues and the industry of patterns, frameworks and consultants that came with them."}),"\n",(0,a.jsx)(t.p,{children:"Event-hidden will become the default web app architecture for the next 10 years."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Next ten years",src:n(2069).A+"",width:"1600",height:"800"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},810:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/event-hidden-arch-buzz-acbaedff9968f8e157c6fd250debb057.png"},558:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/event-hidden-arch-diagram-c1aba9f72902f8e42bba5446da846b8f.png"},2069:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/event-hidden-arch-next-ten-years-78dc2ca9ab2712500e8846371ee1355e.png"},9316:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/event-hidden-arch-revolution-b2990c52168724f15247afff08c8b1e3.png"},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var i=n(6540);const a={},r=i.createContext(a);function s(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:t},e.children)}},6376:e=>{e.exports=JSON.parse('{"permalink":"/blog/event-hidden-arch","source":"@site/blog/event_hidden_arch.md","title":"Event-Hidden Architectures","description":"Interactive features without events","date":"2025-04-21T00:00:00.000Z","tags":[],"readingTime":5.39,"hasTruncateMarker":true,"authors":[{"name":"Charles Zedlewski","title":"SkipLabs Advisor","url":"https://www.linkedin.com/in/charleszedlewski/","key":"charles","page":null}],"frontMatter":{"title":"Event-Hidden Architectures","description":"Interactive features without events","slug":"event-hidden-arch","date":"2025-04-21T00:00:00.000Z","authors":"charles"},"unlisted":false,"nextItem":{"title":"New built-in resources for Skip services","permalink":"/blog/non-reactive-dependencies"}}')}}]);