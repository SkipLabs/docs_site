"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[7411],{5414:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>n,toc:()=>c});var n=a(941),i=a(4848),s=a(8453);const o={title:"Why Skip?",description:"Why use the Skip framework?",slug:"why-skip",date:new Date("2025-02-11T12:00:01.000Z"),authors:"jverlaguet"},r=void 0,l={authorsImageUrls:[void 0]},c=[];function d(e){const t={img:"img",li:"li",ol:"ol",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Skip After Meta"})}),"\n",(0,i.jsx)(t.p,{children:"Facebook allowed us to open source both Hack and Skiplang so we could share both with the larger engineering community.  I eventually decided to leave Facebook (now Meta) to build on the work of Hack and Skiplang and develop technologies that would address the same challenges we had at Facebook but for engineers generally.  To do this, SkipLabs needed to incorporate two new technologies to make the work we did at Facebook usable in a normal engineering context."}),"\n","\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"A way to manage objects transactionally as their state changes"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This is an essential and unique design choice in Skip\u2019s approach to incremental computation.  Without it, developers have to program against streams and assume a large and insidiously subtle amount of complexity.  Incremental computation will only become mainstream if the dev and ops time experience is simpler and easier than the more common request/response paradigm, not just faster & continuous."}),"\n",(0,i.jsx)(t.p,{children:"Object handling needed to go beyond simple caching.  We needed an in-memory system of objects and collections that could maintain an up-to-date view of the data as it changed which we call **reactive collections**."}),"\n",(0,i.jsx)(t.p,{children:"Most of the objects in a program can be managed with memoization: storing and reusing the results of expensive computations.  This can be fast, simple and efficient provided you know when to evict the memoized values."}),"\n",(0,i.jsx)(t.p,{children:"In Skip, memoized objects are held in \u201cLazy Collections.\u201d They compute and cache results only when needed clients and will automatically evict data from the cache to save memory."}),"\n",(0,i.jsx)(t.p,{children:"Other objects serve as indices or dictionaries. These objects realistically cannot be memoized as every value in the dictionary needs to be up to date at all times.  Skip manages these objects as \u201cEager Collections,\u201d keeping them in memory at all times and recomputing whenever a source updates."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Skip runtime internals diagram",src:a(5813).A+"",width:"1999",height:"976"})}),"\n",(0,i.jsxs)(t.ol,{start:"2",children:["\n",(0,i.jsx)(t.li,{children:"An ability to program services that compute incrementally but in familiar languages."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Skiplang was built from the ground up to support incremental computing and it\u2019s very well suited to that purpose.  Realistically engineering teams outside of Meta have already picked their languages and stacks and it would be unrealistic to expect everyone to change to meet Skip."}),"\n",(0,i.jsx)(t.p,{children:"We realized we could bring the most essential characteristics of Skiplang to already widely used languages, starting with TypeScript.  Skip aims to allow developers to implement programs declaratively while the framework automatically manages the state and decides what parts of the graph of computation need to be re-run.  For this to work, programs need to be deterministic, effect free and assume they are interacting with objects in a transactional heap."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Skip runtime application stack",src:a(3225).A+"",width:"1999",height:"1268"})}),"\n",(0,i.jsx)(t.p,{children:"The Skip Runtime integrates with popular Typescript runtimes (e.g. Node, Bun) and using proxy objects gives Typescript a reactive, transactional heap.  We then added a Typescript API that gives developers a simple programming model of map functions applied to the objects Skip is now holding in its transactional heap.  In this way, developers get to stick with their preferred language while Skip can transparently manage both the state of the objects and directs when different parts of a program are recomputed."}),"\n",(0,i.jsx)(t.p,{children:"We added higher level features to the API to more easily manipulate those collections (filter, slice, join, etc ...), and added support for sub-collections (collections created while computing the entry of a collection), among other things.  In the future we think there\u2019s an opportunity to add other (optional) higher level primitives to make building complex services even easier."}),"\n",(0,i.jsx)(t.p,{children:"Today the Skip Framework exclusively supports TypeScript.  We plan to add support for Python and Java in the near future and other languages in the medium term."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"The Skip Framework"})}),"\n",(0,i.jsx)(t.p,{children:"By combining a programming model that enforced effect-free operations on immutable objects with a runtime that abstracted away state and data management details, Skip has grown from a language to a full framework that we\u2019ve recently released."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Why Skip is useful"})}),"\n",(0,i.jsx)(t.p,{children:"Skip can power services that perform any combination of reads and writes but the main benefits are experienced with reads.  Skip gives read-based features & functions several advantages over the more typical request/response model."}),"\n",(0,i.jsx)(t.p,{children:"Skip programs will:"}),"\n",(0,i.jsx)(t.p,{children:"Continuously react to changes in data and clients - by managing the state of objects and the impact of functions on those objects, Skip services can incrementally recompute and stream new values to clients without recomputing unchanged values unnecessarily."}),"\n",(0,i.jsx)(t.p,{children:"Automatically manage their own state - a feature may need to fetch data from multiple sources, compute intermediate results in a specific order while hydrating & invalidating different caches.  In Skip all of this complexity is handled by the framework.  Developers just write functions against collections for a single point in time."}),"\n",(0,i.jsx)(t.p,{children:"Let you introspect their execution - reactive programs are historically challenging to inspect and debug.  Because the Skip runtime manages both the objects and their graph of computation, Skip programs are very easy to introspect.  We plan to add a debugger to the framework to capitalize on this part of the design."}),"\n",(0,i.jsx)(t.p,{children:"Work alongside traditional request / response programs - Unlike past approaches to state management and reactivity, we wanted to make sure Skip was not an \u201call or nothing\u201d engineering decision.  Vertically, Skip can run in one or several layers of an existing software stack. It can read and write data from preexisting REST services, streaming sources or some legacy backend.  Skip can also power a new service where it reads and writes from a traditional database."}),"\n",(0,i.jsx)(t.p,{children:"Horizontally, Skip can power some or all the features of an application\u2019s backend and coexists with other business logic written in other frameworks, languages, etc.  Within Skip\u2019s context it's very easy to extend what you\u2019ve implemented in a service through a feature called \u201cmirroring\u201d that lets a new service import and synchronize data from a pre-existing peer service."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Why it feels awesome to use Skip"})}),"\n",(0,i.jsx)(t.p,{children:'Skip lets developers focus on the "what" instead of the "how." By defining the desired outcome declaratively, Skip generates the necessary logic to keep data live and reactive. It handles complexities like cache invalidation and recomputation efficiently without adding any cognitive burden for the developer.'}),"\n",(0,i.jsx)(t.p,{children:"We took a graph-based approach to the Skip programming model. You define your computation as a series of operations on collections, creating a **graph of reactive computations**. Each node in the graph can be a lazy or eager collection, and the framework automatically manages dependencies, updates, and cache invalidation for you."}),"\n",(0,i.jsx)(t.p,{children:"Here\u2019s the magic: You write your program as if **time is frozen**, defining static outputs in terms of static inputs.  Skip then turns this into a live, streaming system. If an input changes, the framework efficiently propagates updates to the affected parts of the graph, ensuring everything stays consistent. It even supports transactional updates, so you can modify multiple inputs simultaneously without breaking consistency."}),"\n",(0,i.jsx)(t.p,{children:"This approach not only makes building incremental features easier but also scales better as the system grows. By focusing on what you want to build and letting Skip handle the rest, developers can deliver live, interactive features without the typical headaches."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Why Skip matters"})}),"\n",(0,i.jsx)(t.p,{children:"Skip isn\u2019t just about solving caching or problems of incremental computation, it\u2019s about rethinking how we build systems that deal with constantly changing data. By giving developers tools to handle immutability, caching, and reactivity seamlessly, Skip makes it easier to write reliable, efficient, fast and scalable applications."}),"\n",(0,i.jsx)(t.p,{children:"By combining the lessons learned from Facebook\u2019s early challenges with the innovation of Skip, we\u2019ve charted a path toward solving some of the most complex problems in real-time and reactive systems. This is just the beginning, and we\u2019re excited to see where this journey takes us next."})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},5813:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/why_skip_runtime_diagram-6fd1189100dc284f6230addeab291097.png"},3225:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/why_skip_stack_diagram-188ec39fb0cadfa25f50309b93dad915.png"},8453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>r});var n=a(6540);const i={},s=n.createContext(i);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(s.Provider,{value:t},e.children)}},941:e=>{e.exports=JSON.parse('{"permalink":"/blog/why-skip","source":"@site/blog/why_skip.md","title":"Why Skip?","description":"Why use the Skip framework?","date":"2025-02-11T12:00:01.000Z","tags":[],"readingTime":6.335,"hasTruncateMarker":true,"authors":[{"name":"Julien Verlaguet","title":"SkipLabs Founder & CEO","url":"https://x.com/JulienVerlaguet","key":"jverlaguet","page":null}],"frontMatter":{"title":"Why Skip?","description":"Why use the Skip framework?","slug":"why-skip","date":"2025-02-11T12:00:01.000Z","authors":"jverlaguet"},"unlisted":false,"nextItem":{"title":"Skip\'s Origins","permalink":"/blog/skips-origins"}}')}}]);