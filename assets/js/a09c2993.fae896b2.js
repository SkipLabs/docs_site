"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[5899],{7974:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"introduction","title":"Introduction","description":"Overview","source":"@site/docs/introduction.md","sourceDirName":".","slug":"/introduction","permalink":"/docs/introduction","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","next":{"title":"Getting started","permalink":"/docs/getting_started"}}');var i=n(4848),o=n(8453);const a={},s="Introduction",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Core concepts",id:"core-concepts",level:2}];function l(e){const t={em:"em",h1:"h1",h2:"h2",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Skip"})," is an open-source framework that enables software developers to build and run reactive services and systems."]}),"\n",(0,i.jsxs)(t.p,{children:["Skip services expose reactive ",(0,i.jsx)(t.em,{children:"resources"}),": data and computation outputs which can be queried over HTTP by non-reactive clients or subscribed to by reactive clients to receive updates in real time."]}),"\n",(0,i.jsx)(t.p,{children:"Skip services are written in a declarative style, defining a reactive computation graph over some input data.\nUnder the hood, the Skip framework efficiently evaluates and updates reactive computations, delivering up-to-date and correct results without incurring heavy recomputation costs or requiring any bug-prone explicit handling of dependency tracking or change propagation."}),"\n",(0,i.jsx)(t.h2,{id:"core-concepts",children:"Core concepts"}),"\n",(0,i.jsxs)(t.p,{children:["The main components of the ",(0,i.jsx)(t.em,{children:"Skip Runtime"}),", the reactive computation engine at the core of the Skip system, are ",(0,i.jsx)(t.em,{children:"collections"})," and ",(0,i.jsx)(t.em,{children:"mappers"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Collections and mappers together form a graph of data and computation dependencies that the engine can use to efficiently maintain reactive computations as inputs and data are updated."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Collections"})," are the core data structure over which reactive computations operate, they are the ",(0,i.jsx)(t.em,{children:"vertices"})," of the Skip reactive computation graph.\nA collection consists of ",(0,i.jsx)(t.em,{children:"elements"}),", each of which associates one or more ",(0,i.jsx)(t.em,{children:"values"})," to a ",(0,i.jsx)(t.em,{children:"key"}),".\nKeys and values can be arbitrary JSON data."]}),"\n",(0,i.jsxs)(t.p,{children:["Collections can either be ",(0,i.jsx)(t.em,{children:"eager"}),", meaning they are always kept up-to-date, or ",(0,i.jsx)(t.em,{children:"lazy"}),", meaning that values are only computed or updated in response to queries for a particular key."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Mappers"})," are values that express a computation from elements of one collection to elements of another collection. Mappers form the ",(0,i.jsx)(t.em,{children:"edges"})," of the Skip reactive computation graph, specifying transformations and compositions of data to produce intermediate results and outputs."]}),"\n",(0,i.jsx)(t.p,{children:"Crucially, mappers must be deterministic and side-effect free, so that the reactive runtime can re-execute them as needed to maintain results that are both up-to-date and guaranteed from-scratch consistent (that is, exactly the same as the result that would be computed if the equivalent non-reactive computation were executed from scratch on the current input)."})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var r=n(6540);const i={},o=r.createContext(i);function a(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);