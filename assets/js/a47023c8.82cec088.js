"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[2053],{8472:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var a=n(3487),i=n(4848),s=n(8453);const o={title:"Skip's Origins",description:"Describe the origins of the Skip framework and programming language.",slug:"skips-origins",date:new Date("2025-02-11T12:00:00.000Z"),authors:"jverlaguet"},r=void 0,c={authorsImageUrls:[void 0]},l=[];function d(e){const t={img:"img",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Coping with success"})}),"\n",(0,i.jsx)(t.p,{children:"I joined a much-smaller-than-today\u2019s Facebook in 2011 to work on what would eventually become the developer tools team. At the time I joined, the engineering team was in the hundreds and the tools we had for development were, well, not great. PHP was the backbone of almost everything, with millions of lines of code. JavaScript was secondary, and only a few critical services ran on other languages. The company was scaling rapidly, and our development practices weren\u2019t keeping up."}),"\n",(0,i.jsx)(t.p,{children:"As the codebase grew, so did the difficulty of maintaining and improving it.  Facebook became much more feature rich and simple enhancements became complicated and error prone.  Often new features needed to operate conditionally on how other preexisting features were already operating.  Essentially with each new layer of features teams added, state management became a greater concern."}),"\n","\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Power of type systems"})}),"\n",(0,i.jsx)(t.p,{children:"Facebook\u2019s codebase relied heavily on dynamic constructs called \u201cgatekeepers\u201d that determined which features were live for which users under different conditions. But these gatekeepers could change which code paths were executed in ways that weren\u2019t always obvious during development."}),"\n",(0,i.jsx)(t.p,{children:"The inability to recreate the state of a path made testing and refactoring a nightmare. Imagine this: you tweak a method, and three weeks later, you\u2019re woken up at 3 AM because your change broke something deep in the application. Over time developers stopped touching critical parts of the codebase. Instead of refactoring and improving existing code, they\u2019d build parallel versions\u2014hacks on top of hacks. The technical debt was piling up, and we needed a way to make changes safely and confidently."}),"\n",(0,i.jsx)(t.p,{children:"We believed we could use types to make deeper static analysis and automatic refactoring possible in the PHP language and this would help engineers bring some order to the chaos.  The system was called Hack. Adoption wasn\u2019t immediate\u2014there was some resistance\u2014but over time, developers saw the value. We intentionally designed the type system to be more flexible than strictly \u201ccorrect.\u201d This decision allowed us to cover more of the codebase quickly, even if it meant making some trade-offs in precision. It worked. Hack became the default way to write PHP at Facebook, and it\u2019s still in use today."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Incrementality"})}),"\n",(0,i.jsx)(t.p,{children:'As Facebook applications grew denser and more layered, more teams were looking to add real-time features where users\u2019 actions immediately impact others, like clicking a "Like" button and instantly updating the count across everyone\u2019s apps.  Such features are essential because performance and interactivity grew user engagement. When an application feels fresh and interactive, it\u2019s much more appealing than static content. However, implementing this in a scalable way is not straightforward.'}),"\n",(0,i.jsx)(t.p,{children:"A typical scenario: you fetch a Facebook post. Normally, the server retrieves data like the post\u2019s text, the number of likes, and the comments. It applies rules to filter and prioritize what\u2019s shown (e.g., highlighting the most relevant comments or enforcing privacy settings). This logic runs once and produces a static result\u2014the post you see on your screen."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Non-reactive request flow",src:n(7030).A+"",width:"1468",height:"572"})}),"\n",(0,i.jsx)(t.p,{children:'Making this "live" means the post updates automatically. If someone likes it, the count changes instantly. If a comment gets edited or deleted, it reflects for everyone in real time. Achieving this requires "inverting the arrow."  Traditionally, a user\u2019s actions\u2014like adding a comment\u2014 produces a write to the database. To make things reactive, engineers needed to turn these writes into continuous streams of updates. For example:'}),"\n",(0,i.jsxs)(t.p,{children:["1. ",(0,i.jsx)(t.strong,{children:"User likes a post"})," \u2192 Create a stream of updates for that post\u2019s like count.\n2. ",(0,i.jsx)(t.strong,{children:"User adds a comment"})," \u2192 Create a stream for the comments section."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Reactive request flow",src:n(93).A+"",width:"1468",height:"572"})}),"\n",(0,i.jsx)(t.p,{children:"Typically reactive frameworks compose these streams into live updates. While conceptually straightforward, this approach fell short because:"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Excessive recomputations"}),": Each small change could require recalculating the entire post, which is expensive and inefficient."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Caching problems"}),": To compute incrementally but avoid excessive fetching and recomputation, you need caches. But managing caches as objects are mutated becomes a nightmare\u2014how do you ensure they\u2019re up-to-date without introducing inconsistencies?"]}),"\n",(0,i.jsx)(t.p,{children:'Caches can work well for "hot" data\u2014frequently accessed data with a short lifespan. But outside this narrow use case, caching comes with trade-offs:'}),"\n",(0,i.jsxs)(t.p,{children:["1. ",(0,i.jsx)(t.strong,{children:"Long TTL (Time-to-Live)"}),": Keeps data in the cache longer, but risks showing stale or inconsistent data.\n2. ",(0,i.jsx)(t.strong,{children:"Manual Invalidation"}),": Requires custom logic to invalidate caches when data changes. This is extremely error-prone and hard to maintain."]}),"\n",(0,i.jsx)(t.p,{children:"For large-scale systems like Facebook, neither approach was sustainable. We needed a better solution."}),"\n",(0,i.jsx)(t.p,{children:"We created Skiplang to better serve our needs for better state management and real-time features & services.  We believed we could use our experience developing type systems to flip the way we think about reactive systems. Instead of starting with database writes and building logic from there, Skiplang let you:"}),"\n",(0,i.jsxs)(t.p,{children:["1. ",(0,i.jsx)(t.strong,{children:"Define the Desired Output"}),": Begin with what you want to build (e.g. a Facebook post).\n2. ",(0,i.jsx)(t.strong,{children:"Use Declarative Rules"}),": Specify what data is needed and how it\u2019s combined."]}),"\n",(0,i.jsxs)(t.p,{children:["Skiplang was originally designed to handle incremental computation and caching, but its capabilities quickly expanded to address the needs of reactive features and efficient data handling.  We built Skiplang on the premise that ",(0,i.jsx)(t.strong,{children:"cached objects were immutable"})," - unchangeable once created. If we could guarantee that immutability, it would be easier to use static analysis of Skiplang\u2019s typed language to track dependencies and know exactly when to invalidate the cache and where to recompute.  Traditional programming languages didn\u2019t give us the tools to enforce these guarantees."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},7030:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/skips_origins_nonreactive_flow-27b5b4e943dfe82e44c7963cdcba989e.png"},93:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/skips_origins_reactive_flow-3e80732b4a2c80754a7c693c91fc5806.png"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var a=n(6540);const i={},s=a.createContext(i);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:t},e.children)}},3487:e=>{e.exports=JSON.parse('{"permalink":"/blog/skips-origins","source":"@site/blog/skips_origins.md","title":"Skip\'s Origins","description":"Describe the origins of the Skip framework and programming language.","date":"2025-02-11T12:00:00.000Z","tags":[],"readingTime":4.495,"hasTruncateMarker":true,"authors":[{"name":"Julien Verlaguet","title":"SkipLabs Founder & CEO","url":"https://x.com/JulienVerlaguet","key":"jverlaguet","page":null}],"frontMatter":{"title":"Skip\'s Origins","description":"Describe the origins of the Skip framework and programming language.","slug":"skips-origins","date":"2025-02-11T12:00:00.000Z","authors":"jverlaguet"},"unlisted":false,"prevItem":{"title":"Why Skip?","permalink":"/blog/why-skip"},"nextItem":{"title":"Skip alpha","permalink":"/blog/skip-alpha"}}')}}]);