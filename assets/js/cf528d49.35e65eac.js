"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[6880],{9131:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"service","title":"Services","description":"Architecture","source":"@site/docs/service.md","sourceDirName":".","slug":"/service","permalink":"/docs/service","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var c=o(4848),n=o(8453);const s={},r="Services",a={},l=[{value:"Architecture",id:"architecture",level:2},{value:"<code>SkipService</code>",id:"skipservice",level:2},{value:"<code>Resource</code>s",id:"resources",level:2},{value:"External resources",id:"external-resources",level:2},{value:"Lazy collections",id:"lazy-collections",level:2},{value:"Client",id:"client",level:2}];function d(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(t.header,{children:(0,c.jsx)(t.h1,{id:"services",children:"Services"})}),"\n",(0,c.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,c.jsx)(t.p,{children:"client, reactive server, REST server, external resources"}),"\n",(0,c.jsx)(t.h2,{id:"skipservice",children:(0,c.jsx)(t.code,{children:"SkipService"})}),"\n",(0,c.jsxs)(t.p,{children:["A reactive Skip service is defined by a class implementing the ",(0,c.jsx)(t.code,{children:"SkipService"})," interface.\nSkip services operate over data organized into ",(0,c.jsx)(t.em,{children:"collections"}),", each of which has a unique string name and associates ",(0,c.jsx)(t.em,{children:"keys"})," to one or more ",(0,c.jsx)(t.em,{children:"values"}),".\nThe contents of collections are computed from initial data, other collections, or reactive or non-reactive external resources.\nIt can be useful to think of the structure of a service's computation as a directed acyclic graph where the vertices are the named collections, and the edges are the functions from input collections to output collections.\nPart of the graph is structured in a way that is not dependent on the data or requests the service encounters at runtime, it is ",(0,c.jsx)(t.em,{children:"static"}),".\nThe rest of the graph is ",(0,c.jsx)(t.em,{children:"dynamic"})," in the sense that collections/vertices are added in response to requests and data received at runtime by the service.\nThe static portion of the graph is defined by the ",(0,c.jsx)(t.code,{children:"initialData"})," and ",(0,c.jsx)(t.code,{children:"reactiveCompute"}),".\nThe vertices of the static graph are the collections specified by the ",(0,c.jsx)(t.code,{children:"SkipService"}),"'s ",(0,c.jsx)(t.code,{children:"initialData: Record<string, [Json, Json[]]"}),", which provides (possibly empty) initial data for each collection.\nThe edges of the static graph are defined by the ",(0,c.jsx)(t.code,{children:"SkipService"}),"'s ",(0,c.jsx)(t.code,{children:"reactiveCompute"}),":"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{children:"reactiveCompute(\n  inputCollections: Record<string, EagerCollection<Json, Json>>,\n  context: Context,\n): Record<string, EagerCollection<Json, Json>>;\n"})}),"\n",(0,c.jsxs)(t.p,{children:["The ",(0,c.jsx)(t.code,{children:"reactiveCompute"})," function will receive ",(0,c.jsx)(t.code,{children:"inputCollections"})," that contains collections formed from the ",(0,c.jsx)(t.code,{children:"initialData"}),", associated to corresponding ",(0,c.jsx)(t.code,{children:"string"})," names.\nFrom the ",(0,c.jsx)(t.code,{children:"inputCollections"})," the ",(0,c.jsx)(t.code,{children:"reactiveCompute"})," function will produce another record associating collections with names, where the collections can come from the inputs or the collection APIs such as ",(0,c.jsx)(t.code,{children:"EagerCollection.map"}),"."]}),"\n",(0,c.jsxs)(t.p,{children:["Some of a Skip service's collections, those of type ",(0,c.jsx)(t.code,{children:"EagerCollection"}),", are eagerly kept up-to-date by the framework.\nThis includes the static portion of the computation graph, so the static portion serves as pre-computed data that can be used by individual requests."]}),"\n",(0,c.jsxs)(t.h2,{id:"resources",children:[(0,c.jsx)(t.code,{children:"Resource"}),"s"]}),"\n",(0,c.jsxs)(t.p,{children:[(0,c.jsx)(t.code,{children:"Resource"}),"s are the mechanism by which a service's collections are exposed to other services and clients.\nA ",(0,c.jsx)(t.code,{children:"Resource"})," implementation provides a ",(0,c.jsx)(t.code,{children:"reactiveCompute"})," function:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{children:"reactiveCompute(\n  collections: Record<string, EagerCollection<Json, Json>>,\n  context: Context,\n  reactiveAuth?: Uint8Array,\n): EagerCollection<Json, Json>;\n"})}),"\n",(0,c.jsxs)(t.p,{children:["which is similar to ",(0,c.jsx)(t.code,{children:"SkipService.reactiveCompute"})," but only produces a single collection, and also receives a ",(0,c.jsx)(t.code,{children:"reactiveAuth"})," token (described below).\nThe simplest ",(0,c.jsx)(t.code,{children:"Resource"}),"s just return one of the collections they receive as an argument, thereby exposing a collection that would otherwise be hidden within the service.\n",(0,c.jsx)(t.code,{children:"Resource"}),"s also define the ",(0,c.jsx)(t.em,{children:"dynamic"})," portion of the computation graph that arises in response to requests and data at runtime, extending the ",(0,c.jsx)(t.em,{children:"static"})," computation graph constructed by ",(0,c.jsx)(t.code,{children:"SkipService.reactiveCompute"}),"."]}),"\n",(0,c.jsxs)(t.p,{children:[(0,c.jsx)(t.code,{children:"Resource"}),"s are defined by a ",(0,c.jsx)(t.code,{children:"SkipService"})," implementation providing ",(0,c.jsx)(t.code,{children:"resources: Record<string, new (params: Record<string, string>) => Resource>"})," that associates resource names to ",(0,c.jsx)(t.code,{children:"Resource"})," constructors.\nThe interface involves constructors since ",(0,c.jsx)(t.code,{children:"Resource"}),"s are instantiated at runtime by the Skip framework in response to requests.\nThe constructor parameters are obtained from the request parameters. // TODO: these are decoded from the URL is the usual way with a URL suffix of the form ?key1=val1&key2=val2&...&keyN=valN,\n// TODO: How are requests and the names of resources matched up? The resource names become collection names, and the replication protocol (e.g. to request to tail a collection) refers to them directly (well, b64 encoded, but whatever).\nThe REST service that provides the external interface to the skip service responds to requests according to server/src/rest.ts, which defines a URL scheme that depends on the names of resources. Need a separate document that explicitly goes through all the endpoints, and point to it from here."]}),"\n",(0,c.jsxs)(t.p,{children:["When a ",(0,c.jsx)(t.code,{children:"SkipService"})," receives a request, the corresponding ",(0,c.jsx)(t.code,{children:"Resource"})," constructor is called with parameters obtained from the request, the instance's ",(0,c.jsx)(t.code,{children:"reactiveCompute"})," function produces a collection with the results, which is returned as the result of the request, to which the requestor may subscribe.\nThis new collection is then maintained up-to-date, with updates being reactively pushed to subscribers."]}),"\n",(0,c.jsx)(t.h2,{id:"external-resources",children:"External resources"}),"\n",(0,c.jsxs)(t.p,{children:["Reactive computation functions receive a Skip runtime ",(0,c.jsx)(t.code,{children:"Context"})," in addition to the input collections."]}),"\n",(0,c.jsx)(t.h2,{id:"lazy-collections",children:"Lazy collections"}),"\n",(0,c.jsx)(t.p,{children:"Explain that lazy collections memoize computations that are made as part of computing the result of an update to an input of an eager collection. Lazy collections cannot be directly exposed as resources, but docs should give an example of how to use a couple auxiliary eager collections to achieve the same thing. (One eager collection that will be written to, containing the keys for which the lazy collection should be computed, and another eager collection for the output that associates keys to their values, that is just a map over the input eager collection that performs a lookup in the lazy collection.)"}),"\n",(0,c.jsx)(t.h2,{id:"client",children:"Client"}),"\n",(0,c.jsx)(t.p,{children:"Need to say how a client is expected to interact with the service. Will point to the docs for the endpoints a service exposes. Need to explain it is a regular connection, and set the header to indicate that a stream should be started in order to tail a collection."})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,c.jsx)(t,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>r});var i=o(6540);const c={},n=i.createContext(c);function s(e){const t=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),i.createElement(n.Provider,{value:t},e.children)}}}]);