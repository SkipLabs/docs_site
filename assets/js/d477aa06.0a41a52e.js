"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[6721],{4274:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"functions","title":"Writing functions","description":"The Skip reactive computation runtime maintains a directed graph, with vertices containing application data and edges describing the computations that produce and manipulate that data.","source":"@site/docs/functions.md","sourceDirName":".","slug":"/functions","permalink":"/docs/functions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Getting started","permalink":"/docs/getting_started"},"next":{"title":"Services and Resources","permalink":"/docs/resources"}}');var r=t(4848),s=t(8453);const a={},o="Writing functions",c={},p=[{value:"Overview",id:"overview",level:2},{value:"Examples",id:"examples",level:2}];function u(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"writing-functions",children:"Writing functions"})}),"\n",(0,r.jsxs)(n.p,{children:["The Skip reactive computation runtime maintains a directed graph, with ",(0,r.jsx)(n.em,{children:"vertices"})," containing application data and ",(0,r.jsx)(n.em,{children:"edges"})," describing the computations that produce and manipulate that data.\nThis graph is used to automatically invalidate and re-evaluate computations when their input dependencies change -- but, it requires your application logic to be written in a form that supports this tracking of dependencies and re-evaluation!"]}),"\n",(0,r.jsx)(n.p,{children:"This section describes the invariants your code must satisfy, gives some examples, and explains the guardrails that the Skip runtime puts in place to prevent common pitfalls."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["Skip mapper functions must be ",(0,r.jsx)(n.em,{children:"side-effect-free"})," and ",(0,r.jsx)(n.em,{children:"deterministic"})," in order to reliably and intuitively run in the Skip runtime environment, which will reevaluate them (when their inputs change) and reuse their results (when their outputs are _un_changed)."]}),"\n",(0,r.jsx)(n.p,{children:"Out-of-band dependencies on imperative mutable state outside of the Skip heap can lead to stale results when that state changes.\nSimilarly, if a reactive computation mutates some external data, that mutation can happen repeatedly when inputs to the computation change, potentially causing bugs if the mutation is not idempotent."}),"\n",(0,r.jsxs)(n.p,{children:["Non-determinism can produce unexpected behavior in a reactive environment, since changing outputs will propagate through the computation graph, potentially incurring significant reevaluation costs.\nThe main invariant that the Skip runtime guarantees is ",(0,r.jsx)(n.em,{children:"from-scratch consistency"})," (i.e. reactive outputs are precisely the same as if the full computation were reexecuted from scratch, without any caching or reuse) which is weakened by non-determinisism.\nAlthough non-determinism is not necessarily a bug in the strictest sense, it can make reactive systems difficult to reason about and should be used only with careful consideration."]}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsxs)(n.p,{children:["Mappers must implement the Skip ",(0,r.jsx)(n.code,{children:"Mapper"})," interface and define a ",(0,r.jsx)(n.code,{children:"mapElement"})," function which takes a key and corresponding values from an input collection and produces some key/value pairs defining an output collection."]}),"\n",(0,r.jsxs)(n.p,{children:["All keys and values must be JSON-encodable (i.e. extend ",(0,r.jsx)(n.code,{children:"Json"}),"), but the input collection's key/value types ",(0,r.jsx)(n.code,{children:"K1"}),"/",(0,r.jsx)(n.code,{children:"V1"})," do not need to coincide with the output collection's key/value types ",(0,r.jsx)(n.code,{children:"K2"}),"/",(0,r.jsx)(n.code,{children:"V2"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface Mapper<\n  K1 extends Json,\n  V1 extends Json,\n  K2 extends Json,\n  V2 extends Json,\n> {\n  mapEntry(key: K1, values: Values<V1>): Iterable<[K2, V2]>;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["First, let us revisit the example ",(0,r.jsx)(n.code,{children:"Mapper"})," from the ",(0,r.jsx)(n.a,{href:"/docs/getting_started",children:"previous section"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Mapper function to compute the active users of each group\nclass ActiveMembers implements Mapper<GroupID, Group, GroupID, UserID> {\n  constructor(private users: EagerCollection<UserID, User>) {}\n\n  mapEntry(gid: GroupID, group: Values<Group>): Iterable<[GroupID, UserID]> {\n    return group\n      .getUnique()\n      .members.flatMap((uid) =>\n        this.users.getUnique(uid).active ? [[gid, uid]] : [],\n      );\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The type instantiation ",(0,r.jsx)(n.code,{children:"Mapper<GroupID, Group, GroupID, UserID>"})," indicates that this ",(0,r.jsx)(n.code,{children:"Mapper"})," will be applied over a collection with ",(0,r.jsx)(n.code,{children:"GroupID"})," keys and ",(0,r.jsx)(n.code,{children:"Group"})," values, and produce a collection with ",(0,r.jsx)(n.code,{children:"GroupID"})," keys and ",(0,r.jsx)(n.code,{children:"UserID"})," values.\nNote that while this function is mapped over a ",(0,r.jsx)(n.code,{children:"GroupID"})," to ",(0,r.jsx)(n.code,{children:"Group"})," collection, it also has access to the ",(0,r.jsx)(n.code,{children:"users"})," collection provided to the constructor, and can read from ",(0,r.jsx)(n.code,{children:"users"})," while processing each entry.\nThe Skip Runtime tracks that the output collection depends on both the input collection as well as the ",(0,r.jsx)(n.code,{children:"users"})," collection, and keeps the output collection up-to-date in reaction to changes to either dependency."]}),"\n",(0,r.jsx)(n.p,{children:"Extending that social media application with Users and Groups example, suppose we want to maintain an index providing the set of groups of which each user is a member.\nFirst, we define a mapper function:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Mapper function to compute the groups each user belongs to\nclass GroupsPerUser implements Mapper<GroupID, Group, UserID, GroupID> {\n  mapEntry(gid: GroupID, group: Values<Group>): Iterable<[UserID, GroupID]> {\n    return group.getUnique().members.map((uid) => [uid, gid]);\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Then, given an eager collection ",(0,r.jsx)(n.code,{children:"groups"})," of type ",(0,r.jsx)(n.code,{children:"EagerCollection<GroupID, Group>"}),", we can create an eager collection of groups per user:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const groupsPerUser: EagerCollection<UserID, GroupID> = groups.map(GroupsPerUser);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This general form of ",(0,r.jsx)(n.code,{children:"Mapper"})," allows arbitrary manipulation of collections' key/value structure.\nFor example, note that the key types of the input and output collections of ",(0,r.jsx)(n.code,{children:"GroupsPerUser"})," are different, as are the value types."]}),"\n",(0,r.jsxs)(n.p,{children:["Simpler mappers can maintain input collections' key/value structure ",(0,r.jsx)(n.em,{children:"one-to-one"})," (mapping one input value to one output value for the same key); for example, to compute each user's number of friends, we can define a ",(0,r.jsx)(n.code,{children:"Mapper"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Mapper function to compute each user's number of friends\nclass NumFriendsPerUser implements Mapper<UserID, User, UserID, number> {\n  mapEntry(uid: UserID, user: Values<User>): Iterable<[UserID, number]> {\n    return [[uid, user.getUnique().friends.length]];\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It is also common to collapse multiple values for a single key down to some aggregate with a ",(0,r.jsx)(n.em,{children:"many-to-one"})," ",(0,r.jsx)(n.code,{children:"Mapper"}),"; for example, to compute the number of active users in each group:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Mapper function to compute a _count_ of active users per group\nclass NumActiveMembers implements Mapper<GroupID, UserID, GroupID, number> {\n  mapEntry(gid: GroupID, uids: Values<UserID>): Iterable<[GroupID, number]> {\n    return [[gid, uids.toArray().length]];\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["By mapping ",(0,r.jsx)(n.code,{children:"NumActiveMembers"})," over the eager collection of active group members, we can produce an eager collection ",(0,r.jsx)(n.code,{children:"activeMembers.map(NumActiveMembers)"})," of type ",(0,r.jsx)(n.code,{children:"EagerCollection<GroupID, number>"})," with counts of active users per group, maintained up-to-date as users' activity status and group memberships change."]}),"\n",(0,r.jsxs)(n.p,{children:["Note that this particular mapper -- counting the number of values per key -- would be better implemented as a ",(0,r.jsx)(n.code,{children:"Reducer"}),", which is in fact available as a generic utility ",(0,r.jsx)(n.code,{children:"Count"})," in Skip with a fast native implementation; this example is provided just to demonstrate use of a collapsing ",(0,r.jsx)(n.code,{children:"Mapper"}),"."]})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);