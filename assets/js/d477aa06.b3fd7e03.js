"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[6721],{7375:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"functions","title":"Writing functions","description":"The Skip reactive computation runtime maintains a directed graph, with vertices containing application data and edges describing the computations that produce and manipulate that data.","source":"@site/docs/functions.md","sourceDirName":".","slug":"/functions","permalink":"/docs/functions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Getting started","permalink":"/docs/getting_started"},"next":{"title":"Services and Resources","permalink":"/docs/resources"}}');var i=t(4848),r=t(8453);const a={},o="Writing functions",c={},u=[{value:"Overview",id:"overview",level:2},{value:"Examples",id:"examples",level:2}];function l(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"writing-functions",children:"Writing functions"})}),"\n",(0,i.jsxs)(n.p,{children:["The Skip reactive computation runtime maintains a directed graph, with ",(0,i.jsx)(n.em,{children:"vertices"})," containing application data and ",(0,i.jsx)(n.em,{children:"edges"})," describing the computations that produce and manipulate that data.\nThis graph is used to automatically invalidate and re-evaluate computations when their input dependencies change -- but, it requires your application logic to be written in a form that supports this tracking of dependencies and re-evaluation!"]}),"\n",(0,i.jsx)(n.p,{children:"This section describes the invariants your code must satisfy, gives some examples, and explains the guardrails that the Skip runtime puts in place to prevent common pitfalls."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:["Skip mapper functions must be ",(0,i.jsx)(n.em,{children:"side-effect-free"})," and ",(0,i.jsx)(n.em,{children:"deterministic"})," in order to reliably and intuitively run in the Skip runtime environment, which will reevaluate them (when their inputs change) and reuse their results (when their outputs are _un_changed)."]}),"\n",(0,i.jsx)(n.p,{children:"Out-of-band dependencies on imperative mutable state outside of the Skip heap can lead to stale results when that state changes.\nSimilarly, if a reactive computation mutates some external data, that mutation can happen repeatedly when inputs to the computation change, potentially causing bugs if the mutation is not idempotent."}),"\n",(0,i.jsxs)(n.p,{children:["Non-determinism can produce unexpected behavior in a reactive environment, since changing outputs will propagate through the computation graph, potentially incurring significant reevaluation costs.\nThe main invariant that the Skip runtime guarantees is ",(0,i.jsx)(n.em,{children:"from-scratch consistency"})," (i.e. reactive outputs are precisely the same as if the full computation were reexecuted from scratch, without any caching or reuse) which is weakened by non-determinisism.\nAlthough non-determinism is not necessarily a bug in the strictest sense, it can make reactive systems difficult to reason about and should be used only with careful consideration."]}),"\n",(0,i.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsxs)(n.p,{children:["Mappers must implement the Skip ",(0,i.jsx)(n.code,{children:"Mapper"})," interface and define a ",(0,i.jsx)(n.code,{children:"mapElement"})," function which takes a key and corresponding values from an input collection and produces some key/value pairs defining an output collection."]}),"\n",(0,i.jsxs)(n.p,{children:["All keys and values must be JSON-encodable (i.e. extend ",(0,i.jsx)(n.code,{children:"Json"}),"), but the input collection's key/value types ",(0,i.jsx)(n.code,{children:"K1"}),"/",(0,i.jsx)(n.code,{children:"V1"})," do not need to coincide with the output collection's key/value types ",(0,i.jsx)(n.code,{children:"K2"}),"/",(0,i.jsx)(n.code,{children:"V2"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface Mapper<\n  K1 extends Json,\n  V1 extends Json,\n  K2 extends Json,\n  V2 extends Json,\n> {\n  mapElement(key: K1, values: NonEmptyIterator<V1>): Iterable<[K2, V2]>;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"For example, in a social media application with Users and Groups, we might want to maintain the set of active users for each group.\nFirst, we define a mapping function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class ActiveUsersByGroup implements Mapper<UserID, User, GroupID, UserID> {\n  mapElement(\n    uid: UserID,\n    users: NonEmptyIterator<User>,\n  ): Iterable<[GroupID, UserID]> {\n    const user = users.uniqueValue();\n    if (user.isActive) return user.groups.map((gid) => [gid, uid]);\n    else return [];\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Then, given an eager collection ",(0,i.jsx)(n.code,{children:"users"})," of type ",(0,i.jsx)(n.code,{children:"EagerCollection<UserID, User>"}),", we can create an eager collection of active group members:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const activeGroupMembers : EagerCollection<GroupID, UserID> = users.map(ActiveUsersByGroup);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This general form of ",(0,i.jsx)(n.code,{children:"Mapper"})," allows arbitrary manipulation of collections' key/value structure, but is often unnecessary and clunky for simple maps, especially those that preserve the key structure of their input and just manipulate the values."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, to maintain a ",(0,i.jsx)(n.em,{children:"count"})," of active users per group, we can define a ",(0,i.jsx)(n.code,{children:"ManyToOneMapper"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class CountUsers extends ManyToOneMapper<GroupID, UserID, number> {\n  mapValues(values: NonEmptyIterator<UserID>): number {\n    return values.toArray().length;\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Then, map over the eager collection of group members to produce an eager collection ",(0,i.jsx)(n.code,{children:"activeGroupMembers.map(CountUsers)"})," of type ",(0,i.jsx)(n.code,{children:"EagerCollection<GroupID, number>"})," which maintains up-to-date counts of active users per group, as users' activity status and group memberships change.\nNote that this mapper -- counting the number of values per key -- is available as a generic utility ",(0,i.jsx)(n.code,{children:"CountMapper"})," in Skip; this example is provided just to demonstrate a use of ",(0,i.jsx)(n.code,{children:"ManyToOneMapper"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The simplest form of mapper maintains input collections' key/value structure one-to-one.\nFor example, to compute the number of groups each user belongs to, we can define a ",(0,i.jsx)(n.code,{children:"OneToOneMapper"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class GroupsPerUser extends OneToOneMapper<UserID, User, number> {\n  mapValue(user: User) : number {\n    return user.groups.length\n  }\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);