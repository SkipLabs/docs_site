"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[8864],{942:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>o,contentTitle:()=>c,default:()=>l,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"resources","title":"Services and Resources","description":"The Skip framework supports end-to-end reactive programming: computations are evaluated reactively within each service, and data is pushed eagerly from reactive services to their consumers.","source":"@site/docs/resources.md","sourceDirName":".","slug":"/resources","permalink":"/docs/resources","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Writing functions","permalink":"/docs/functions"},"next":{"title":"External data sources","permalink":"/docs/externals"}}');var n=t(4848),i=t(8453);const a={},c="Services and Resources",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Resource HTTP API",id:"resource-http-api",level:2},{value:"Streaming API",id:"streaming-api",level:3},{value:"Control API",id:"control-api",level:3}];function h(e){const r={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"services-and-resources",children:"Services and Resources"})}),"\n",(0,n.jsx)(r.p,{children:"The Skip framework supports end-to-end reactive programming: computations are evaluated reactively within each service, and data is pushed eagerly from reactive services to their consumers."}),"\n",(0,n.jsxs)(r.p,{children:["We've already seen the ",(0,n.jsx)(r.em,{children:"intra"}),"-service abstractions -- collections, mappers, and the like -- that make up a reactive service's computation graph (see the ",(0,n.jsx)(r.a,{href:"/docs/getting_started",children:"getting started"})," and ",(0,n.jsx)(r.a,{href:"/docs/functions",children:"writing functions"})," pages)."]}),"\n",(0,n.jsxs)(r.p,{children:["This page describes the concepts and abstractions that make up the ",(0,n.jsx)(r.em,{children:"inter"}),"-service communication layer."]}),"\n",(0,n.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsxs)(r.p,{children:["A Skip ",(0,n.jsx)(r.a,{href:"api/api/interfaces/SkipService",children:"reactive service"})," describes a reactive computation from some set of inputs to some set of outputs."]}),"\n",(0,n.jsxs)(r.p,{children:["A service's inputs are its ",(0,n.jsx)(r.em,{children:"input collections"})," (data owned by the service that can be freely read/written/mapped over) and its ",(0,n.jsx)(r.em,{children:"external services"})," (any dependencies on outside systems or APIs)."]}),"\n",(0,n.jsxs)(r.p,{children:["A service's outputs are its ",(0,n.jsx)(r.em,{children:"resource"}),", which define the types of requests that the service can handle, either by accessing data from its static computation graph or by dynamically extending it with further reactive computation as needed to handle the request.\nIn this way, we can think of resources as parameterized outputs; request parameters are used to instantiate the resource and produce a ",(0,n.jsx)(r.em,{children:"resource instance"})," containing the requested data."]}),"\n",(0,n.jsxs)(r.p,{children:['For a concrete example, take the "active friends" resource from the getting-started ',(0,n.jsx)(r.a,{href:"/docs/getting_started#the-anatomy-of-a-skip-service",children:"example"})," service:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-typescript",children:"const service = await runService({\n  initialData: { users, groups },\n  resources: { active_friends: ActiveFriends },\n  createGraph(input: ServiceInputs): ResourceInputs {\n    const actives = input.groups.map(ActiveUsers, input.users);\n    return { users: input.users, actives };\n  },\n});\n"})}),"\n",(0,n.jsxs)(r.p,{children:["The service has two input collections ",(0,n.jsx)(r.code,{children:'"users"'})," and ",(0,n.jsx)(r.code,{children:'"groups"'})," (populated here with some initial data), no external dependencies (i.e. the service definition does not define the optional ",(0,n.jsx)(r.code,{children:"externalServices"})," field), and one resource: ",(0,n.jsx)(r.code,{children:"ActiveFriends"}),", defined as follows:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-typescript",children:'class ActiveFriends implements Resource<ResourceInputs> {\n  private uid: UserID;\n\n  constructor(params: { [param: string]: Json }) {\n    if (!params["uid"]) throw new Error("Missing required parameter \'uid\'");\n    this.uid = params["uid"];\n  }\n\n  instantiate(inputs: ResourceInputs): EagerCollection<GroupID, UserID> {\n    const user = inputs.users.getUnique(this.uid);\n    return inputs.actives.map(FilterFriends, user);\n  }\n}\n'})}),"\n",(0,n.jsxs)(r.p,{children:["In this setup, the reactive service exposes some routes corresponding to the resource, each expecting an HTTP query parameter ",(0,n.jsx)(r.code,{children:"uid"}),".\nWhen a request is made, the ",(0,n.jsx)(r.code,{children:"constructor"})," is invoked with the given parameters and then ",(0,n.jsx)(r.code,{children:"instantiate"})," called on the resulting object, extending the static computation graph (which updates ",(0,n.jsx)(r.code,{children:"inputs"}),") with additional reactive computation, getting the relevant ",(0,n.jsx)(r.code,{children:"user"})," and filtering active users according to whether or not they are friends.\nThe eager collection returned by the ",(0,n.jsx)(r.code,{children:"instantiate"})," function is the output served to the client for this request, reactively updating according to any changes to input data: users, groups, friend relationships, etc."]}),"\n",(0,n.jsxs)(r.p,{children:["This ",(0,n.jsx)(r.em,{children:"resource instance"})," can be explicitly closed by the client, or it will be garbage collected by the Skip framework after a period of inactivity."]}),"\n",(0,n.jsxs)(r.p,{children:['When a Skip service depends on the output of another Skip service, its "request" for a resource instance is made using the ',(0,n.jsx)(r.a,{href:"api/api/interfaces/Context#useexternalresource",children:(0,n.jsx)(r.code,{children:"Context#useExternalResource"})})," API.\nAfter registering an external service ",(0,n.jsx)(r.code,{children:'"myOtherService"'})," (as described ",(0,n.jsx)(r.a,{href:"/docs/externals",children:"here"}),") with some ",(0,n.jsx)(r.code,{children:'"my_resource"'}),", your service can call ",(0,n.jsx)(r.code,{children:'context.useExternalResource("myOtherService", "my_resource", params)'})," to access that resource with the given parameters, allowing reactive computation to propagate through multiple services."]}),"\n",(0,n.jsx)(r.h2,{id:"resource-http-api",children:"Resource HTTP API"}),"\n",(0,n.jsxs)(r.p,{children:["Skip reactive services expose a REST API across two separate ports: a ",(0,n.jsx)(r.em,{children:"streaming"})," port for public-facing data streaming, and a ",(0,n.jsx)(r.em,{children:"control"})," port for stream creation/deletion and synchronous reads/writes.\nThis bifurcation makes it easier to redirect clients directly to streaming endpoints while avoiding exposing sensitive control routes publicly."]}),"\n",(0,n.jsx)(r.h3,{id:"streaming-api",children:"Streaming API"}),"\n",(0,n.jsx)(r.p,{children:"The data streaming API (on port 8080 by default) consists of a single endpoint:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{children:"GET /v1/streams/:uuid\n"})}),"\n",(0,n.jsxs)(r.p,{children:["After instantiating a resource and receiving the corresponding UUID (via the control API), clients can query this endpoint to receive initial data and updates via server-sent events, as described ",(0,n.jsx)(r.a,{href:"/docs/client",children:"here"}),"."]}),"\n",(0,n.jsx)(r.h3,{id:"control-api",children:"Control API"}),"\n",(0,n.jsx)(r.p,{children:"The control API (on port 8081 by default) surfaces resource instantiation/deletion operations and synchronous read/write operations."}),"\n",(0,n.jsx)(r.p,{children:"Resource instantiation and deletion are controlled by two routes:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{children:"POST /v1/streams/:resource\nDELETE /v1/streams/:uuid\n"})}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.code,{children:"POST"})," route instantiates the named resource parameterized by the JSON-encoded request body and returns a UUID identifying the resource, which can then be used in a query to the streaming API.\nThe ",(0,n.jsx)(r.code,{children:"DELETE"})," route closes and tears down the resource instance identified by its ",(0,n.jsx)(r.code,{children:"uuid"})," parameter, terminating any active streams."]}),"\n",(0,n.jsx)(r.p,{children:"Synchronous reads from reactive resources can either access the resource in its entirety or read the data for a single key, using routes:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{children:"POST /v1/snapshot/:resource\nPOST /v1/snapshot/:resource/lookup\n"})}),"\n",(0,n.jsxs)(r.p,{children:["The first route returns all of the entries in the named ",(0,n.jsx)(r.code,{children:"resource"}),", using the parameters provided in the JSON-encoded request body.\nIt instantiates the resource if needed, then returns a JSON-encoded array of key/value entries, with each entry a tuple of the form ",(0,n.jsx)(r.code,{children:"[key, [value1, value2, ...]]"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["The second route requires the request body to be a JSON-encoded value with a ",(0,n.jsx)(r.code,{children:"key"})," field and a ",(0,n.jsx)(r.code,{children:"params"})," field.\nIt instantiates the resource if needed, then returns a JSON-encoded array of all values associated to ",(0,n.jsx)(r.code,{children:"key"})," in the resource."]}),"\n",(0,n.jsx)(r.p,{children:"Lastly, clients can update the input collections of a reactive service:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{children:"PATCH /v1/inputs/:collection\n"})}),"\n",(0,n.jsxs)(r.p,{children:["This route updates an input collection ",(0,n.jsx)(r.code,{children:"collection"})," with the value(s) passed in its JSON-encoded request payload.\nIt updates multiple keys simultaneously with the data in the body of the request, which must be an array of ",(0,n.jsx)(r.code,{children:"[K, V[]]"})," entries for the key/value types ",(0,n.jsx)(r.code,{children:"K"})," and ",(0,n.jsx)(r.code,{children:"V"})," of the input collection."]}),"\n",(0,n.jsxs)(r.p,{children:["For example, with ",(0,n.jsx)(r.code,{children:"string"})," keys and ",(0,n.jsx)(r.code,{children:"number"})," values, a request body of ",(0,n.jsx)(r.code,{children:'[["key1",[10,20]],["key2",[]],["key3",[50]]]'})," associates ",(0,n.jsx)(r.code,{children:"key1"})," to the values ",(0,n.jsx)(r.code,{children:"10"})," and ",(0,n.jsx)(r.code,{children:"20"}),", deletes any values under ",(0,n.jsx)(r.code,{children:"key2"}),", and associates ",(0,n.jsx)(r.code,{children:"key3"})," to the value 50."]})]})}function l(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,r,t)=>{t.d(r,{R:()=>a,x:()=>c});var s=t(6540);const n={},i=s.createContext(n);function a(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);